# Adapted from https://github.com/awslabs/aws-cloudformation-templates/blob/master/aws/services/ECS/FargateLaunchType/services/public-service.yml
AWSTemplateFormatVersion: '2010-09-09'
Description: Deploy a service on AWS Fargate, hosted in a public subnet, and accessible via a public load balancer.
Parameters:
  NetworkStackName:
    Type: String
  ClusterStackName:
    Type: String
  ServiceName:
    Type: String
  ImageUrl:
    Type: String
  ContainerPort:
    Type: Number
    Default: 80
  ContainerCpu:
    Type: Number
    Default: 256
  ContainerMemory:
    Type: Number
    Default: 512
  Path:
    Type: String
    Default: "*"
  Priority:
    Type: Number
    Default: 1000
  DesiredCount:
    Type: Number
    Default: 2
  Role:
    Type: String
    Default: ""
    Description: (Optional) An IAM role to give the service's containers if the code within needs to
                 access other AWS resources like S3 buckets, DynamoDB tables, etc
  MaxTaggedContainerImagesToRetain:
    Type: Number
    Description: The number of tagged container images to retain before expiring
    MinValue: 1
    MaxValue: 100
    ConstraintDescription: Value must be between 1 and 100
    Default: 10
  DaysToRetainUntaggedContainerImages:
    Type: Number
    Description: The number days to retain untagged container images before expiring
    MinValue: 1
    MaxValue: 100
    ConstraintDescription: Value must be between 1 and 100
    Default: 7

Conditions:
  HasCustomRole: !Not [ !Equals [!Ref 'Role', ''] ]

Resources:

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref 'ServiceName'
      Cpu: !Ref 'ContainerCpu'
      Memory: !Ref 'ContainerMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: {'Fn::ImportValue': !Sub '${ClusterStackName}:ECSTaskExecutionRole'}
      TaskRoleArn:
        Fn::If:
          - 'HasCustomRole'
          - !Ref 'Role'
          - !Ref "AWS::NoValue"
      ContainerDefinitions:
        - Name: !Ref 'ServiceName'
          Cpu: !Ref 'ContainerCpu'
          Memory: !Ref 'ContainerMemory'
          Image: !Ref 'ImageUrl'
          PortMappings:
            - ContainerPort: !Ref 'ContainerPort'

  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  Service:
    Type: AWS::ECS::Service
    DependsOn: LoadBalancerRule
    Properties:
      ServiceName: !Ref 'ServiceName'
      Cluster: {'Fn::ImportValue': !Sub '${ClusterStackName}:ClusterName'}
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 75
      DesiredCount: !Ref 'DesiredCount'
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - {'Fn::ImportValue': !Sub '${ClusterStackName}:FargateContainerSecurityGroup'}
          Subnets:
            - {'Fn::ImportValue': !Sub '${NetworkStackName}:PublicSubnet1Id'}
            - {'Fn::ImportValue': !Sub '${NetworkStackName}:PublicSubnet2Id'}
      TaskDefinition: !Ref 'TaskDefinition'
      LoadBalancers:
        - ContainerName: !Ref 'ServiceName'
          ContainerPort: !Ref 'ContainerPort'
          TargetGroupArn: !Ref 'TargetGroup'

  # A target group. This is used for keeping track of all the tasks, and
  # what IP addresses / port numbers they have. You can query it yourself,
  # to use the addresses yourself, but most often this target group is just
  # connected to an application load balancer, or network load balancer, so
  # it can automatically distribute traffic across all the targets.
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      TargetType: ip
      Name: !Ref 'ServiceName'
      Port: !Ref 'ContainerPort'
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: {'Fn::ImportValue': !Sub '${NetworkStackName}:VpcId'}

  # Create a rule on the load balancer for routing traffic to the target group
  LoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'TargetGroup'
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values: [!Ref 'Path']
      ListenerArn:
        Fn::ImportValue:
          !Join [':', [!Ref 'ClusterStackName', 'PublicListener']]
      Priority: !Ref 'Priority'

  # Simple Amazon ECR Lifecycle Policies to try and reduce storage costs
  # See: https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html
  EcrDockerRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: example
      LifecyclePolicy:
        LifecyclePolicyText: !Sub
          - |
            {
              "rules": [
                {
                  "rulePriority": 1,
                  "description": "Only keep untagged images for ${DaysToRetainUntaggedContainerImages} days",
                  "selection": {
                    "tagStatus": "untagged",
                    "countType": "sinceImagePushed",
                    "countUnit": "days",
                    "countNumber": ${DaysToRetainUntaggedContainerImages}
                  },
                  "action": { "type": "expire" }
                },
                {
                  "rulePriority": 2,
                  "description": "Keep only ${MaxTaggedContainerImagesToRetain} tagged images, expire all others",
                  "selection": {
                    "tagStatus": "tagged",
                    "tagPrefixList": ["0"],
                    "countType": "imageCountMoreThan",
                    "countNumber": ${MaxTaggedContainerImagesToRetain}
                  },
                  "action": { "type": "expire" }
                }
              ]
            }
          - DaysToRetainUntaggedContainerImages: !Ref DaysToRetainUntaggedContainerImages
            MaxTaggedContainerImagesToRetain: !Ref MaxTaggedContainerImagesToRetain
